{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "Compute Registration (elastix)",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets using the elastix library.\n- Needs Elastix profiles to configure the registration.\n- Calculates registration transforms e.g. per FOV by providing FOV_ROI_table.\n- Can handle cases where there are more than one embryo / organoid in a FOV if each ROI e.g. embryo / organoid is masked by a linked label (e.g. calculated by`scMultiplex Calculate Object Linking`) and corresponding masking_roi_table. Assumes label_id to be the same across cycles, but soesn't require FOVs to have the same shape.\n- Typically used as the first task in a workflow, followed by `Apply Registration (elastix)`.\n\n### Output\n- Calculates transformation parameters for **per (ROI)** and stores the results in a registration subfolder of OME-Zarr container.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n",
      "type": "compound",
      "executable_non_parallel": "fractal_tasks/init_registration_hcs.py",
      "executable_parallel": "fractal_tasks/compute_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitRegistrationHcs"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration. Choose `0` to process at full resolution. Currently only level 0 is supported."
          },
          "ref_wavelength_id": {
            "title": "Ref Wavelength Id",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration as the reference; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "mov_wavelength_id": {
            "title": "Mov Wavelength Id",
            "type": "string",
            "description": "(Optional) wavelength that will be used for image-based registration for moving images; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "parameter_files": {
            "items": {
              "type": "string"
            },
            "title": "Parameter Files",
            "type": "array",
            "description": "Paths to the elastix parameter files to be used. List order is order of registration. E.g. parse first rigid, then affine and lastly bspline."
          },
          "lower_rescale_quantile": {
            "default": 0.0,
            "title": "Lower Rescale Quantile",
            "type": "number",
            "description": "Lower quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0."
          },
          "upper_rescale_quantile": {
            "default": 0.99,
            "title": "Upper Rescale Quantile",
            "type": "number",
            "description": "Upper quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0.99."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": " If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `embryo_ROI_table`)."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Optional label for masking ROI e.g. `embryo`."
          },
          "skip_failed_rois": {
            "default": true,
            "title": "Skip Failed Rois",
            "type": "boolean",
            "description": "If `True`, ROIs that fail during registration will be skipped and the task will continue with the next ROI. An identity transformation will be written for the failed ROIs and a condition table will be added to the OME-Zarr listing the ROIs with issues."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "ref_wavelength_id",
          "parameter_files"
        ],
        "type": "object",
        "title": "ComputeRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Apply Registration (elastix)",
      "output_types": {
        "registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** from `Compute Registration (elastix)` task to images in an **HCS** OME-Zarr dataset, aligning all acquisitions to a specified reference acquisition.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the second task in a workflow, following `Compute Registration (elastix)`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/apply_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 16,
        "mem": 60000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          },
          "output_image_suffix": {
            "default": "registered",
            "title": "Output Image Suffix",
            "type": "string",
            "description": "Name of the output image suffix. E.g. \"registered\"."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table which has been used during computation of registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should be loaded."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Name of the label that will be used for masking. If `use_masks=True`, the label image will be used to mask the bounding box of the ROI table. If `use_masks=False`, the whole bounding box will be loaded."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether the old image data should be replaced with the newly registered image data."
          }
        },
        "required": [
          "zarr_url",
          "roi_table"
        ],
        "type": "object",
        "title": "ApplyRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Compute Registration (warpfield)",
      "input_types": {
        "is_3D": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets based on [warpfield](https://github.com/danionella/warpfield).\n- Takes warpfield registration recipe, if None is provided default registration recipe is applied. \n- Can handle cases where there are more than one embryo / organoid in a FOV if each ROI e.g. embryo / organoid is masked by a linked label (e.g. calculated by`scMultiplex Calculate Object Linking`) and corresponding masking_roi_table. Assumes label_id to be the same across cycles, but doesn't require FOVs to have the same shape.\n- Typically used as the first task in a workflow, followed by `Apply Registration (warpfield)`.\n\n### Output\n- Calculates transformation **warpmap per (ROI)** and stores the results in a registration subfolder of the OME-Zarr container.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n- Requires GPU with Cuda > 11.x .\n- For **Pelkmans cluster** the following parameters need to be provided manually during Worker Initialisation:\n    ```\n    export NVCC_PREPEND_FLAGS=\"--std=c++17\"\n    ```\n",
      "type": "compound",
      "executable_non_parallel": "fractal_tasks/init_registration_hcs.py",
      "executable_parallel": "fractal_tasks/compute_registration_warpfield.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitRegistrationHcs"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration."
          },
          "wavelength_id": {
            "title": "Wavelength Id",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "histogram_normalisation": {
            "default": true,
            "title": "Histogram Normalisation",
            "type": "boolean",
            "description": "If `True`, applies histogram normalisation to the moving image before calculating the registration. Default: `True`."
          },
          "path_to_registration_recipe": {
            "title": "Path To Registration Recipe",
            "type": "string",
            "description": "Path to the warpfield .yml registration recipe. This parameter is optional, if not provided, the default .yml recipe will be used."
          },
          "save_reg_video": {
            "default": false,
            "title": "Save Reg Video",
            "type": "boolean",
            "description": "If `True`, saves the video showing the registration in registration folder. Default: `False`."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": " If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `embryo_ROI_table`)."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Optional label for masking ROI e.g. `embryo`."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite existing registration files. Default: `False`."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "level",
          "wavelength_id"
        ],
        "type": "object",
        "title": "ComputeRegistrationWarpfield"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Apply Registration (warpfield)",
      "input_types": {
        "is_3D": true
      },
      "output_types": {
        "registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** from `Compute Registration (warpfield)` task to images in an **HCS** OME-Zarr dataset, aligning all acquisitions to a specified reference acquisition.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the second task in a workflow, following `Compute Registration (warpfield)`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/apply_registration_warpfield.py",
      "meta_parallel": {
        "cpus_per_task": 16,
        "mem": 60000,
        "needs_gpu": true
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Which resolution level to apply the registration on. Must match the level that was used during computation of the registration."
          },
          "output_image_suffix": {
            "default": "registered",
            "title": "Output Image Suffix",
            "type": "string",
            "description": "Name of the output image suffix. E.g. \"registered\"."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table which has been used during computation of registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should be loaded."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Name of the label that will be used for masking. If `use_masks=True`, the label image will be used to mask the bounding box of the ROI table. If `use_masks=False`, the whole bounding box will be loaded."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether the old image data should be replaced with the newly registered image data."
          }
        },
        "required": [
          "zarr_url",
          "roi_table"
        ],
        "type": "object",
        "title": "ApplyRegistrationWarpfield"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Compute Channel Registration (elastix)",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets using the elastix library.\n- Needs Elastix profiles to configure the registration.\n- Processes images grouped by well, under the assumption that each well contains one image per acquisition.\n- Calculates transformations for **specified regions of interest (ROIs)** and stores the results in a registration subfolder per OME-Zarr image.\n- Typically used as the first task in a workflow, followed by `Apply Channel Registration (elastix)`.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n- Assumes each well contains a single image per acquisition.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/compute_channel_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "$defs": {
          "IteratorConfiguration": {
            "description": "Advanced configuration.",
            "properties": {
              "roi_table": {
                "title": "Iterate Over ROIs",
                "type": "string",
                "description": "Name of a ROI table. If set, the segmentation will be applied to each ROI in the table individually. This option can be combined with masking."
              }
            },
            "title": "IteratorConfiguration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_wavelength": {
            "title": "Reference Wavelength",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "parameter_files": {
            "items": {
              "type": "string"
            },
            "title": "Parameter Files",
            "type": "array",
            "description": "Paths to the elastix parameter files to be used. Usually a single parameter file with the transformation class SimilarityTransform to compute channel registration."
          },
          "iterator_configuration": {
            "allOf": [
              {
                "$ref": "#/$defs/IteratorConfiguration"
              }
            ],
            "title": "Iterator Configuration",
            "description": "Configuration for the image processing iterator."
          },
          "level_path": {
            "default": 2,
            "title": "Level Path",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration. Choose `0` to process at full resolution."
          },
          "lower_rescale_quantile": {
            "default": 0.0,
            "title": "Lower Rescale Quantile",
            "type": "number",
            "description": "Lower quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0."
          },
          "upper_rescale_quantile": {
            "default": 0.99,
            "title": "Upper Rescale Quantile",
            "type": "number",
            "description": "Upper quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0.99."
          },
          "output_table_name": {
            "default": "Channel_Registration_Transforms",
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the table to be created in the OME-Zarr container to store the registration transformations. Default is \"Channel_Registration_Transforms\"."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "Whether to overwrite existing registration transformations. Default is True."
          }
        },
        "required": [
          "zarr_url",
          "reference_wavelength",
          "parameter_files"
        ],
        "type": "object",
        "title": "ComputeChannelRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Apply Channel Registration (elastix)",
      "input_types": {
        "channels_registered": false
      },
      "output_types": {
        "channels_registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** from `Calculate Channel Registration (elastix)` task to images in an **HCS** OME-Zarr dataset, aligning all channels of an acquisition to a specified reference wavelength.\n- This task is useful if there are wavelength- and sample-dependent chromatic shifts.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the second task in a workflow, following `Calculate Channel Registration (elastix)`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/apply_channel_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "$defs": {
          "IteratorConfiguration": {
            "description": "Advanced configuration.",
            "properties": {
              "roi_table": {
                "title": "Iterate Over ROIs",
                "type": "string",
                "description": "Name of a ROI table. If set, the segmentation will be applied to each ROI in the table individually. This option can be combined with masking."
              }
            },
            "title": "IteratorConfiguration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_wavelength": {
            "title": "Reference Wavelength",
            "type": "string",
            "description": "Against which wavelength the registration was calculated."
          },
          "transformation_table_name": {
            "default": "Channel_Registration_Transforms",
            "title": "Transformation Table Name",
            "type": "string",
            "description": "Name of the table in which the transformations have been stored in preceeding computation task. Defaults to \"Channel_Registration_Transforms\"."
          },
          "iterator_configuration": {
            "allOf": [
              {
                "$ref": "#/$defs/IteratorConfiguration"
              }
            ],
            "title": "Iterator Configuration",
            "description": "Configuration for the segmentation iterator. This can be used to specify masking and/or a ROI table."
          },
          "level_path": {
            "default": 0,
            "title": "Level Path",
            "type": "integer",
            "description": "If the OME-Zarr has multiple resolution levels, the level to use can be specified here. If not provided, the highest resolution level will be used."
          },
          "output_image_suffix": {
            "default": "channels_registered",
            "title": "Output Image Suffix",
            "type": "string",
            "description": "Name of the output image suffix. Defaults to \"channels_registered\"."
          },
          "overwrite_input": {
            "default": false,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether to overwrite the input zarr file with the new registered zarr file. If False, the new registered zarr file will be created with output_image_suffix."
          }
        },
        "required": [
          "zarr_url",
          "reference_wavelength"
        ],
        "type": "object",
        "title": "ApplyChannelRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Convert Cellvoyager Multiplexing to existing OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "Cellvoyager",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Converts **multiplexed 2D and 3D images from CellVoyager CV7000/8000** systems into OME-Zarr format, storing each acquisition as a separate OME-Zarr image, **extending an existing** OME-Zarr plate.\n- Creates **OME-Zarr HCS plates**, combining all fields of view for each acquisition in a well into a single image.\n- Saves Fractal **region-of-interest (ROI) tables** for both individual fields of view and the entire well.\n- Handles overlapping fields of view by adjusting their positions to be non-overlapping, while preserving the original position data as additional columns in the ROI tables.\n\n### Limitations\n- This task currently does not support time-resolved data and ignores the time fields in CellVoyager metadata.\n",
      "type": "converter_compound",
      "executable_non_parallel": "fractal_tasks/cellvoyager_to_ome_zarr_init_extend_multiplex.py",
      "executable_parallel": "fractal_tasks/cellvoyager_compute_omezarr.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "MultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "allowed_channels": {
                "items": {
                  "$ref": "#/$defs/OmeroChannel"
                },
                "title": "Allowed Channels",
                "type": "array"
              }
            },
            "required": [
              "image_dir",
              "allowed_channels"
            ],
            "title": "MultiplexingAcquisition",
            "type": "object"
          },
          "OmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string"
              },
              "index": {
                "title": "Index",
                "type": "integer"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "window": {
                "allOf": [
                  {
                    "$ref": "#/$defs/Window"
                  }
                ],
                "title": "Window"
              },
              "color": {
                "title": "Color",
                "type": "string"
              },
              "active": {
                "default": true,
                "title": "Active",
                "type": "boolean"
              },
              "coefficient": {
                "default": 1,
                "title": "Coefficient",
                "type": "integer"
              },
              "inverted": {
                "default": false,
                "title": "Inverted",
                "type": "boolean"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "OmeroChannel",
            "type": "object"
          },
          "Window": {
            "description": "Custom class for Omero-channel window, based on OME-NGFF v0.4.",
            "properties": {
              "min": {
                "title": "Min",
                "type": "integer"
              },
              "max": {
                "title": "Max",
                "type": "integer"
              },
              "start": {
                "title": "Start",
                "type": "integer"
              },
              "end": {
                "title": "End",
                "type": "integer"
              }
            },
            "required": [
              "start",
              "end"
            ],
            "title": "Window",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path to the directory of the existing OME-Zarr file where the new acquisitions will be added. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "acquisitions": {
            "additionalProperties": {
              "$ref": "#/$defs/MultiplexingAcquisition"
            },
            "title": "Acquisitions",
            "type": "object",
            "description": "dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels."
          },
          "plate_name": {
            "title": "Plate Name",
            "type": "string",
            "description": "If specified, tries to extend an existing plate with this name e.g. `AssayPlate_Greiner_CELLSTAR655090`. If `None`, tries to extract the plate name from the zarr_dir."
          },
          "include_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Include Glob Patterns",
            "type": "array",
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03 `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` => only process well C09, field of view 16 and Z planes 0-59. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process"
          },
          "exclude_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Exclude Glob Patterns",
            "type": "array",
            "description": "If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns."
          },
          "num_levels": {
            "default": 5,
            "title": "Num Levels",
            "type": "integer",
            "description": "Number of resolution-pyramid levels. If set to `5`, there will be the full-resolution level and 4 levels of downsampled images."
          },
          "coarsening_xy": {
            "default": 2,
            "title": "Coarsening Xy",
            "type": "integer",
            "description": "Linear coarsening factor between subsequent levels. If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled etc."
          },
          "image_extension": {
            "default": "tif",
            "title": "Image Extension",
            "type": "string",
            "description": "Filename extension of images (e.g. `\"tif\"` or `\"png\"`)."
          },
          "metadata_table_files": {
            "additionalProperties": {
              "type": "string"
            },
            "title": "Metadata Table Files",
            "type": "object",
            "description": "If `None`, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, a dictionary of key-value pairs like `(acquisition, path)` with `acquisition` a string like the key of the `acquisitions` dict and `path` pointing to a csv file containing the parsed metadata table."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_dir",
          "acquisitions"
        ],
        "type": "object",
        "title": "CellvoyagerToOmeZarrInitExtendMultiplex"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChunkSizes": {
            "description": "Chunk size settings for OME-Zarrs.",
            "properties": {
              "t": {
                "title": "T",
                "type": "integer"
              },
              "c": {
                "default": 1,
                "title": "C",
                "type": "integer"
              },
              "z": {
                "default": 10,
                "title": "Z",
                "type": "integer"
              },
              "y": {
                "title": "Y",
                "type": "integer"
              },
              "x": {
                "title": "X",
                "type": "integer"
              }
            },
            "title": "ChunkSizes",
            "type": "object"
          },
          "InitArgsCellVoyager": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "plate_prefix": {
                "title": "Plate Prefix",
                "type": "string"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              },
              "image_extension": {
                "title": "Image Extension",
                "type": "string"
              },
              "include_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Include Glob Patterns",
                "type": "array"
              },
              "exclude_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Exclude Glob Patterns",
                "type": "array"
              },
              "acquisition": {
                "title": "Acquisition",
                "type": "integer"
              }
            },
            "required": [
              "image_dir",
              "plate_prefix",
              "well_ID",
              "image_extension"
            ],
            "title": "InitArgsCellVoyager",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsCellVoyager",
            "title": "Init Args",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`."
          },
          "chunk_sizes": {
            "$ref": "#/$defs/ChunkSizes",
            "title": "Chunk Sizes",
            "description": "Used to overwrite the default chunk sizes for the OME-Zarr. By default, the task will chunk the same as the microscope field of view size, with 10 z planes per chunk. For example, that can mean c: 1, z: 10, y: 2160, x:2560"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CellvoyagerComputeOmezarr"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Upsample Label Image",
      "category": "Image Processing",
      "tags": [
        "3D"
      ],
      "docs_info": "### Purpose\n- Upsamples segmented **labels** in 2D or 3D images to the highest image resolution.\n- Useful if segmentation was performed at a lower resolution (e.g. level 1).\n\n### Outputs\n- A new **upsampled label image** with resolution matching those of the OME-Zarr images.\n- Preserves the integer label values from the original segmentation.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/upsample_label_image.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Name of the label image to upsample."
          },
          "ref_acquisition": {
            "title": "Ref Acquisition",
            "type": "integer",
            "description": "Optional, if provided the task will not cause an error if the label does not exist for non-reference acquisitions."
          },
          "output_label_name": {
            "title": "Output Label Name",
            "type": "string",
            "description": "Optionally new label name for the upsampled label image."
          },
          "output_ROI_table": {
            "title": "Output Roi Table",
            "type": "string",
            "description": "If provided, a masking ROI table with that name is created, which will contain the bounding boxes of the newly upsampled labels. ROI tables should have `ROI` in their name."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite existing label and ROI table (if set)."
          }
        },
        "required": [
          "zarr_url",
          "label_name"
        ],
        "type": "object",
        "title": "UpsampleLabelImage"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Convert abbott-legacy H5 to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "Cellvoyager",
        "3D"
      ],
      "docs_info": "### Purpose\n- Converts Pelkmans-internal abbott-legacy h5 files to OME-Zarr.\n\n### Outputs\n- OME-Zarr directory with zarr_urls fitting Fractal convention.\n\n### Limitations\n- This task currently only supports 3D data with axes ZYX.\n",
      "type": "converter_compound",
      "executable_non_parallel": "fractal_tasks/convert_abbottlegacyh5_to_omezarr_init.py",
      "executable_parallel": "fractal_tasks/convert_abbottlegacyh5_to_omezarr_compute.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 16,
        "mem": 60000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "AllowedH5Extensions": {
            "description": "Enum for allowed H5 file extensions.",
            "enum": [
              ".h5",
              ".hdf5"
            ],
            "title": "AllowedH5Extensions",
            "type": "string"
          },
          "ConverterMultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "allowed_image_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Image Channels",
                "type": "array"
              },
              "allowed_label_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Label Channels",
                "type": "array"
              }
            },
            "required": [
              "allowed_image_channels"
            ],
            "title": "ConverterMultiplexingAcquisition",
            "type": "object"
          },
          "ConverterOmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "integer"
              },
              "index": {
                "title": "Index",
                "type": "integer"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "new_label": {
                "title": "New Label",
                "type": "string"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "ConverterOmeroChannel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "input_dir": {
            "title": "Input Dir",
            "type": "string",
            "description": "Input path to the folder containing H5 files to be converted."
          },
          "acquisitions": {
            "additionalProperties": {
              "$ref": "#/$defs/ConverterMultiplexingAcquisition"
            },
            "title": "Acquisitions",
            "type": "object",
            "description": "dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels."
          },
          "include_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Include Glob Patterns",
            "type": "array",
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process"
          },
          "exclude_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Exclude Glob Patterns",
            "type": "array",
            "description": "If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns."
          },
          "h5_extension": {
            "allOf": [
              {
                "$ref": "#/$defs/AllowedH5Extensions"
              }
            ],
            "default": ".h5",
            "title": "H5 Extension",
            "description": "Filename extension of h5 files (e.g. `\"h5\"` or `\"hdf5\"`)."
          },
          "plate_name": {
            "default": "AssayPlate_Greiner_CELLSTAR655090",
            "title": "Plate Name",
            "type": "string",
            "description": "Name of the plate that was used to acquire the images."
          },
          "mrf_path": {
            "title": "Mrf Path",
            "type": "string",
            "description": "Provide path to cycle 0 mrf file, typically MeasurementDetail.mrf located in the raw image folder containing tif files."
          },
          "mlf_path": {
            "title": "Mlf Path",
            "type": "string",
            "description": "Same as for mrf, but for the mlf file. Typical name is MeasurementData.mlf."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output. Default is `False`."
          }
        },
        "required": [
          "zarr_dir",
          "input_dir",
          "acquisitions",
          "mrf_path",
          "mlf_path"
        ],
        "type": "object",
        "title": "ConvertAbbottlegacyh5ToOmezarrInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ConverterMultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "allowed_image_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Image Channels",
                "type": "array"
              },
              "allowed_label_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Label Channels",
                "type": "array"
              }
            },
            "required": [
              "allowed_image_channels"
            ],
            "title": "ConverterMultiplexingAcquisition",
            "type": "object"
          },
          "ConverterOMEZarrBuilderParams": {
            "description": "Parameters for the OME-Zarr builder.",
            "properties": {
              "number_multiscale": {
                "default": 4,
                "minimum": 0,
                "title": "Number Multiscale",
                "type": "integer"
              },
              "xy_scaling_factor": {
                "default": 2,
                "maximum": 10,
                "minimum": 1,
                "title": "Scaling Factor xy",
                "type": "integer"
              },
              "z_scaling_factor": {
                "default": 1,
                "maximum": 10,
                "minimum": 1,
                "title": "Z Scaling Factor",
                "type": "integer"
              },
              "max_xy_chunk": {
                "default": 4096,
                "minimum": 1,
                "title": "Max Xy Chunk",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "minimum": 1,
                "title": "Z Chunk",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "minimum": 1,
                "title": "C Chunk",
                "type": "integer"
              }
            },
            "title": "ConverterOMEZarrBuilderParams",
            "type": "object"
          },
          "ConverterOmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "integer"
              },
              "index": {
                "title": "Index",
                "type": "integer"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "new_label": {
                "title": "New Label",
                "type": "string"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "ConverterOmeroChannel",
            "type": "object"
          },
          "ConverterWavelengthModel": {
            "description": "Input model for wavelength conversion.",
            "properties": {
              "wavelength_abbott_legacy": {
                "title": "Wavelength Abbott Legacy",
                "type": "integer"
              },
              "wavelength_omezarr": {
                "title": "Wavelength Omezarr",
                "type": "string"
              }
            },
            "required": [
              "wavelength_abbott_legacy",
              "wavelength_omezarr"
            ],
            "title": "ConverterWavelengthModel",
            "type": "object"
          },
          "CustomWavelengthInputModel": {
            "description": "Input model for the custom wavelength conversions to be used in task.",
            "properties": {
              "wavelengths": {
                "items": {
                  "$ref": "#/$defs/ConverterWavelengthModel"
                },
                "title": "Wavelengths",
                "type": "array"
              }
            },
            "title": "CustomWavelengthInputModel",
            "type": "object"
          },
          "InitArgsCellVoyagerH5toOMEZarr": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "input_files": {
                "items": {
                  "type": "string"
                },
                "title": "Input Files",
                "type": "array"
              },
              "acquisition": {
                "$ref": "#/$defs/ConverterMultiplexingAcquisition",
                "title": "Acquisition"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              },
              "plate_path": {
                "title": "Plate Path",
                "type": "string"
              },
              "mrf_path": {
                "title": "Mrf Path",
                "type": "string"
              },
              "mlf_path": {
                "title": "Mlf Path",
                "type": "string"
              },
              "include_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Include Glob Patterns",
                "type": "array"
              },
              "exclude_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Exclude Glob Patterns",
                "type": "array"
              },
              "overwrite": {
                "title": "Overwrite",
                "type": "boolean"
              }
            },
            "required": [
              "input_files",
              "acquisition",
              "well_ID",
              "plate_path",
              "mrf_path",
              "mlf_path",
              "overwrite"
            ],
            "title": "InitArgsCellVoyagerH5toOMEZarr",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Output path to save the OME-Zarr file of the form `zarr_dir/plate_name/row/column/`."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsCellVoyagerH5toOMEZarr",
            "title": "Init Args",
            "description": "Initialization arguments passed from init task."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "The level of the image to convert. Currently only level 0 is supported."
          },
          "wavelengths": {
            "allOf": [
              {
                "$ref": "#/$defs/CustomWavelengthInputModel"
              }
            ],
            "default": {
              "wavelengths": [
                {
                  "wavelength_abbott_legacy": 405,
                  "wavelength_omezarr": "A01_C01"
                },
                {
                  "wavelength_abbott_legacy": 488,
                  "wavelength_omezarr": "A02_C02"
                },
                {
                  "wavelength_abbott_legacy": 561,
                  "wavelength_omezarr": "A03_C03"
                },
                {
                  "wavelength_abbott_legacy": 640,
                  "wavelength_omezarr": "A04_C04"
                }
              ]
            },
            "title": "Wavelengths",
            "description": "Wavelength conversion dictionary mapping."
          },
          "axes_names": {
            "default": "ZYX",
            "title": "Axes Names",
            "type": "string",
            "description": "The layout of the image data. Currently only implemented for 'ZYX'."
          },
          "ome_zarr_parameters": {
            "allOf": [
              {
                "$ref": "#/$defs/ConverterOMEZarrBuilderParams"
              }
            ],
            "default": {
              "number_multiscale": 4,
              "xy_scaling_factor": 2,
              "z_scaling_factor": 1,
              "max_xy_chunk": 4096,
              "z_chunk": 10,
              "c_chunk": 1
            },
            "title": "Ome Zarr Parameters",
            "description": "Parameters for the OME-Zarr builder."
          },
          "masking_label": {
            "title": "Masking Label",
            "type": "string",
            "description": "Optional label for masking ROI e.g. `embryo`."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "ConvertAbbottlegacyh5ToOmezarrCompute"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2",
  "authors": "Ruth Hornbachner"
}
